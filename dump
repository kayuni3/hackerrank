--a good example that you don't have to pull columns just from tables
--in a way query creates a table and so we can pull from there
select m.hacker_id, h.name, sum(score) as total_score from
(select hacker_id, challenge_id, max(score) as score
from Submissions group by hacker_id, challenge_id) as m
join Hackers as h
on m.hacker_id = h.hacker_id
group by m.hacker_id, h.name
having total_score > 0
order by total_score desc, m.hacker_id;
--having is used instead of where when you use aggregate functions like sum and max here we used greater than 0, sum, and max
--link to more info https://www.sqltutorial.org/sql-having/

--concat combines multiple expressions into one "row"
--left can also be used for substring
select concat(name, '(', substring(occupation, 1, 1), ')') as name
from occupations
order by name
select concat('There are a total of', ' ', count(occupation), ' ', 
lower(occupation), 's.') as profession
from occupations
group by occupation
order by profession
;

-creates a table using MySql what we add in the initial select line becomes are new columns 
select Doctor, Professor, Singer, Actor 
from 
--assigns the new columns titles to the values from the original table
--not sure why max is used
--NameOrder is row criteria and then the case when then statements make the columns 
(select NameOrder, 
max(case occupation when 'Doctor' then name end) as Doctor,
max(case occupation when 'Professor' then name end) as Professor,
max(case occupation when 'Singer' then name end) as Singer,
max(case occupation when 'Actor' then name end) as Actor
--alphabetizes the names using the row_number() function, it "makes a table"/query and then pulls the occupation values from this alphabetical "table" called Names instead
--it assigns each name a row based on this alphabetical order and seperates them based on occupation with the partition by clause
--so basically doctor will be sorted in the first lets say 5 rows and then singer will be sorted in the next 6 
from 
(select occupation, name, row_number() over(partition by Occupation order by name asc) as NameOrder 
from Occupations) as NameLists 
group by NameOrder) 
as Names
--row_number() assign a sequential number to each row in the result set
--partition by breaks the rows into smaller sets similar to group by, order by orders the rows 
-- a link to more info for pivot tables using MySql https://www.dbrnd.com/2015/08/arrange-rows-to-columns-pivot-table-in-mysql/
--link to more info for row_number() function https://www.mysqltutorial.org/mysql-window-functions/mysql-row_number-function/

--Binary Tree
select n,
case 
when p is null then 'Root'
when n in (select p from BST) then 'Inner'
else 'Leaf'
end as "P"
from BST
order by n;
--a node would be an inner if it's parent's value is not null (it's parent has a parent)


--uses the union function to remove dupicates and exists and I haven't used these before
--I honestly do not understand this at all because the question is kinda confusing
select a.x, a.y 
from functions as a
where a.x = a.y and (
    select count(*) 
    from functions 
    where x = a.x and y = a.y) > 1 
 --reads as find a.x and a.y values where a.x and a.y are equal and there is more than one that match their values. 
 --this I believe is what finds the pair
    
union  
  
select a.x, a.y
from functions as a
where exists (
    select x, y
    from functions 
    where a.x = y and a.y = x and a.x < x) 
order by x;
--the a.x < x makes sense because x1 has to be less than and equal to y1 and if y1 is equal to x2 then x1 should be less than x2
--I think using union makes this cleaner and easier
